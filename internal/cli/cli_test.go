package cli

import (
	"reflect"
	"testing"
)

func TestReorderArgs_empty(t *testing.T) {
	got := reorderArgs(nil)

	if len(got) != 0 {
		t.Errorf("got %v, want empty", got)
	}
}

func TestReorderArgs_flags_first(t *testing.T) {
	got := reorderArgs([]string{"--dry-run", "v1.0"})
	want := []string{"--dry-run", "v1.0"}

	if !reflect.DeepEqual(got, want) {
		t.Errorf("got %v, want %v", got, want)
	}
}

func TestReorderArgs_positional_first(t *testing.T) {
	got := reorderArgs([]string{"v1.0", "--dry-run"})
	want := []string{"--dry-run", "v1.0"}

	if !reflect.DeepEqual(got, want) {
		t.Errorf("got %v, want %v", got, want)
	}
}

func TestReorderArgs_o_with_value(t *testing.T) {
	got := reorderArgs([]string{"v1.0", "-o", "out.md", "--verbose"})
	want := []string{"-o", "out.md", "--verbose", "v1.0"}

	if !reflect.DeepEqual(got, want) {
		t.Errorf("got %v, want %v", got, want)
	}
}

func TestReorderArgs_o_equals_value(t *testing.T) {
	got := reorderArgs([]string{"v1.0", "-o=out.md"})
	want := []string{"-o=out.md", "v1.0"}

	if !reflect.DeepEqual(got, want) {
		t.Errorf("got %v, want %v", got, want)
	}
}

func TestReorderArgs_mixed(t *testing.T) {
	got := reorderArgs([]string{"--verbose", "v1.0", "--dry-run", "-o", "notes.md"})
	want := []string{"--verbose", "--dry-run", "-o", "notes.md", "v1.0"}

	if !reflect.DeepEqual(got, want) {
		t.Errorf("got %v, want %v", got, want)
	}
}

func TestReorderArgs_long_output_with_value(t *testing.T) {
	got := reorderArgs([]string{"v1.0", "--output", "out.md"})
	want := []string{"--output", "out.md", "v1.0"}

	if !reflect.DeepEqual(got, want) {
		t.Errorf("got %v, want %v", got, want)
	}
}

func TestReorderArgs_long_output_equals(t *testing.T) {
	got := reorderArgs([]string{"v1.0", "--output=out.md"})
	want := []string{"--output=out.md", "v1.0"}

	if !reflect.DeepEqual(got, want) {
		t.Errorf("got %v, want %v", got, want)
	}
}

func TestReorderArgs_m_with_value(t *testing.T) {
	got := reorderArgs([]string{"v1.0", "-m", "haiku"})
	want := []string{"-m", "haiku", "v1.0"}

	if !reflect.DeepEqual(got, want) {
		t.Errorf("got %v, want %v", got, want)
	}
}

func TestReorderArgs_model_with_value(t *testing.T) {
	got := reorderArgs([]string{"v1.0", "--model", "haiku"})
	want := []string{"--model", "haiku", "v1.0"}

	if !reflect.DeepEqual(got, want) {
		t.Errorf("got %v, want %v", got, want)
	}
}

func TestReorderArgs_model_equals(t *testing.T) {
	got := reorderArgs([]string{"v1.0", "--model=haiku"})
	want := []string{"--model=haiku", "v1.0"}

	if !reflect.DeepEqual(got, want) {
		t.Errorf("got %v, want %v", got, want)
	}
}

func TestParseArgs_version(t *testing.T) {
	cfg, err := ParseArgs("1.0.0", []string{"--version"})
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}

	if cfg != nil {
		t.Error("expected nil config for --version")
	}
}

func TestParseArgs_missing_tag(t *testing.T) {
	_, err := ParseArgs("1.0.0", []string{})
	if err == nil {
		t.Fatal("expected error, got nil")
	}
}

func TestParseArgs_basic(t *testing.T) {
	cfg, err := ParseArgs("1.0.0", []string{"v1.0", "--dry-run"})
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}

	if cfg.Tag != "v1.0" {
		t.Errorf("Tag = %q, want %q", cfg.Tag, "v1.0")
	}

	if !cfg.DryRun {
		t.Error("expected DryRun to be true")
	}

	if cfg.Version != "1.0.0" {
		t.Errorf("Version = %q, want %q", cfg.Version, "1.0.0")
	}
}

func TestParseArgs_with_model(t *testing.T) {
	cfg, err := ParseArgs("1.0.0", []string{"v1.0", "-m", "haiku"})
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}

	if cfg.Model != "haiku" {
		t.Errorf("Model = %q, want %q", cfg.Model, "haiku")
	}
}

func TestParseArgs_with_instructions(t *testing.T) {
	cfg, err := ParseArgs("1.0.0", []string{"v1.0", "Focus on API changes"})
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}

	if cfg.Instructions != "Focus on API changes" {
		t.Errorf("Instructions = %q, want %q", cfg.Instructions, "Focus on API changes")
	}
}

func TestAppendFooter(t *testing.T) {
	got := appendFooter("Some notes\n\n", "0.1.0")

	if got != "Some notes\n\n*Release notes generated by [herald v0.1.0](https://github.com/AndreyAkinshin/herald)*\n" {
		t.Errorf("got %q", got)
	}
}

func TestAppendFooter_no_trailing_newline(t *testing.T) {
	got := appendFooter("Notes", "1.0.0")

	if got != "Notes\n\n*Release notes generated by [herald v1.0.0](https://github.com/AndreyAkinshin/herald)*\n" {
		t.Errorf("got %q", got)
	}
}

func TestAppendFullChangelog(t *testing.T) {
	got := appendFullChangelog("Notes\n", "owner/repo", "v1.0", "v2.0")
	want := "Notes\n\n**Full Changelog**: https://github.com/owner/repo/compare/v1.0...v2.0\n"

	if got != want {
		t.Errorf("got %q, want %q", got, want)
	}
}
